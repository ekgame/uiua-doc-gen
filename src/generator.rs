use crate::extractor::{FunctionArgument, FunctionOutput};
use crate::formatter::format_source_code;
use crate::{
    extractor::{
        BindingDefinition, BindingType, CodeMacroDefinition, Colored, ConstantDefinition, DataDefinition, Definition, Documented, Field,
        FunctionDefinition, IndexMacroDefinition, ItemContent, ModuleDefinition, NamedSignature, SignatureInfo, VariantDefinition,
    },
    summarizer::{DocumentationSummary, RenderingContent, RenderingItem},
};
use kuchiki::traits::TendrilSink;
use leptos::html::Span;
use leptos::{html::Div, view, CollectView, HtmlElement, IntoView, View};
use rand::distributions::Alphanumeric;
use rand::{thread_rng, Rng};
use std::collections::HashMap;
use std::fs::{create_dir_all, remove_dir_all};
use std::path::{Path, PathBuf};
use thiserror::Error;
use uiua::Compiler;
use pulldown_cmark::{html, CodeBlockKind, Event, Options, Parser, Tag, TagEnd};


#[derive(Error, Debug)]
pub enum GenerationError {}

pub fn generate_documentation_site(directory: &Path, summary: DocumentationSummary, compiler: &Compiler) -> Result<(), GenerationError> {
    let output_directory = directory.join("doc-site");
    if output_directory.exists() {
        remove_dir_all(output_directory.clone()).expect("Unable to remove existing output directory");
    }
    create_dir_all(output_directory.clone()).expect("Unable to create output directory");

    let mut mangler = FilenameMangler::new();

    save_static_file(
        &output_directory,
        mangler.mangle_filename("style.css".as_ref()),
        include_bytes!("../design/style.css"),
    );

    save_static_file(
        &output_directory,
        mangler.mangle_filename("script.js".as_ref()),
        include_bytes!("../design/script.js"),
    );

    save_static_file(&output_directory, "Uiua386.ttf".parse().unwrap(), include_bytes!("../design/Uiua386.ttf"));

    save_static_file(
        &output_directory,
        "index.html".parse().unwrap(),
        generate_html(summary, &mut mangler, &compiler).as_bytes(),
    );

    Ok(())
}

struct FilenameMangler {
    map: HashMap<PathBuf, PathBuf>,
}

impl FilenameMangler {
    fn new() -> Self {
        Self { map: HashMap::new() }
    }

    fn mangle_filename(&mut self, path: &Path) -> PathBuf {
        let mut rng = thread_rng();
        let random_string: String = (0..8).map(|_| rng.sample(Alphanumeric) as char).collect();

        let mut new_filename = path.file_stem().unwrap().to_os_string();
        new_filename.push(".");
        new_filename.push(&random_string);
        if let Some(ext) = path.extension() {
            new_filename.push(".");
            new_filename.push(ext);
        }

        let mangled_path = path.with_file_name(new_filename);
        self.map.insert(path.to_path_buf(), mangled_path.clone());
        mangled_path
    }

    fn get_mangled_filename(&self, original: &Path) -> Option<&PathBuf> {
        self.map.get(original)
    }
}

fn save_static_file(output_directory: &Path, file: PathBuf, content: &[u8]) {
    let destination = output_directory.join(file);
    std::fs::write(destination, content).expect("Unable to write static file");
}

fn generate_html(summary: DocumentationSummary, mangler: &mut FilenameMangler, compiler: &Compiler) -> String {
    let page_content = generate_page(summary, mangler, &compiler);
    let raw_output = leptos::ssr::render_to_string(|| page_content).to_string();
    let document = kuchiki::parse_html().from_utf8().one(raw_output.as_bytes());

    // Remove comments
    document
        .inclusive_descendants()
        .filter(|node| node.as_comment().is_some())
        .for_each(|comment| comment.detach());

    // Remove data-hk attributes generated by leptos
    document.select("[data-hk]").unwrap().for_each(|node| {
        node.attributes.borrow_mut().remove("data-hk");
    });

    // Serialize back to string
    let mut result = Vec::new();
    document.serialize(&mut result).unwrap();
    String::from_utf8(result).unwrap()
}

pub fn markdown_to_html(markdown: &str, compiler: &Compiler) -> String {
    let parser = Parser::new_ext(markdown, Options::all());
    let mut in_uiua_code_block = false;
    let mut html_output = String::new();

    let parser = parser.map(|event| match &event {
        Event::Start(Tag::CodeBlock(CodeBlockKind::Fenced(lang))) if lang.to_lowercase() == "uiua" => {
            in_uiua_code_block = true;
            event
        }
        Event::End(TagEnd::CodeBlock) if in_uiua_code_block => {
            in_uiua_code_block = false;
            event
        }
        Event::Text(text) if in_uiua_code_block => {
            Event::Html(format_source_code(&text.trim().to_string(), &compiler).into())
        }
        _ => event,
    });

    html::push_html(&mut html_output, parser);
    html_output
}

fn generate_page(summary: DocumentationSummary, mangler: &mut FilenameMangler, compiler: &Compiler) -> impl IntoView {
    let stylesheet = mangler.get_mangled_filename("style.css".as_ref()).unwrap().to_str().unwrap().to_string();
    let script = mangler.get_mangled_filename("script.js".as_ref()).unwrap().to_str().unwrap().to_string();

    view! {
        <!DOCTYPE html>
        <html lang="en">
            <head>
                <title>{&summary.title}</title>
                <meta charset="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                <link rel="stylesheet" href=stylesheet />
                <script src=script></script>
            </head>
            <body>
                <div class="mobile-container">
                    <div class="mobile-nav">
                        <div class="hamburger">
                            <div class="line"></div>
                            <div class="line"></div>
                            <div class="line"></div>
                        </div>
                        <h1>{&summary.title}</h1>
                    </div>
                    <div class="container">
                        <div class="sidebar">{generate_sidebar(&summary)}</div>
                        <div class="content">
                            <div class="content-wrapper">
                                <h1 class="mobile-hidden">{&summary.title}</h1>
                                {generate_content(&summary, &compiler)}
                            </div>
                        </div>
                    </div>
                </div>
            </body>
        </html>
    }
}

fn generate_sidebar(summary: &DocumentationSummary) -> impl IntoView {
    summary
        .sections
        .iter()
        .map(|section| {
            view! {
                <div class="sidebar-section">
                    <div class="section-name">{&section.title}</div>
                    <ul>
                        {section
                            .content
                            .iter()
                            .flat_map(|item| &item.links)
                            .map(|link| {
                                view! {
                                    <li>
                                        <a href=&link.url>{&link.title}</a>
                                    </li>
                                }
                            })
                            .collect_view()}
                        {section
                            .content
                            .iter()
                            .filter(|item| matches!(&item.content, RenderingContent::Items(_)))
                            .map(|link| match &link.content {
                                RenderingContent::Items(items) => {
                                    view! {
                                        <li>
                                            <a href=format!(
                                                "#{}",
                                                &items.title.link_id,
                                            )>{&items.title.title}</a>
                                        </li>
                                    }
                                }
                                _ => view! { <li>"N/A"</li> },
                            })
                            .collect_view()}
                    </ul>
                </div>
            }
        })
        .collect_view()
}

fn generate_content(summary: &DocumentationSummary, compiler: &Compiler) -> impl IntoView {
    summary
        .sections
        .iter()
        .map(|section| section.content.iter().map(|item| generate_rendering_item(item, &compiler)).collect_view())
        .collect_view()
}

fn generate_rendering_item(item: &RenderingItem, compiler: &Compiler) -> impl IntoView {
    match &item.content {
        RenderingContent::RenderedDocumentation(ref content) => view! { <div class="panel" inner_html=content></div> },
        RenderingContent::Items(ref item) => view! {
            <div>
                <h2 id=&item.title.link_id>{&item.title.title}</h2>
                {item.items.iter().map(|item| generate_content_item(None, item, &compiler)).collect_view()}
            </div>
        },
    }
}

fn generate_content_item(parent_module: Option<String>, item: &ItemContent, compiler: &Compiler) -> Option<HtmlElement<Div>> {
    match item {
        ItemContent::Binding(binding) => Some(generate_binding_item(parent_module, binding, &compiler)),
        ItemContent::Module(module) => Some(generate_module_item(parent_module, module, &compiler)),
        ItemContent::Data(data) => Some(generate_data_item(parent_module, data, &compiler)),
        ItemContent::Variant(variant) => Some(generate_variant_item(parent_module, variant, &compiler)),
        ItemContent::Words { .. } | ItemContent::Import(_) => None,
    }
}

fn generate_binding_item(parent_module: Option<String>, item: &BindingDefinition, compiler: &Compiler) -> HtmlElement<Div> {
    match &item.kind {
        BindingType::Const(constant) => generate_constant_item(parent_module, item, constant, &compiler),
        BindingType::Function(function) => generate_function_item(parent_module, item, function, compiler),
        BindingType::IndexMacro(index_macro) => generate_index_macro_item(parent_module, item, index_macro, &compiler),
        BindingType::CodeMacro(code_macro) => generate_code_macro_item(parent_module, item, code_macro, &compiler),
    }
}

fn module_qualifier(module: String) -> View {
    view! {
        <span class="binding module">{module}</span>
        <span>"~"</span>
    }
    .into()
}

fn documentation(item: &impl Documented, compiler: &Compiler) -> impl IntoView {
    item.comment()
        .map(|comment| view! { <div class="feature-documentation" inner_html=markdown_to_html(comment, compiler) /> })
}

fn generate_constant_item(parent_module: Option<String>, item: &BindingDefinition, constant: &ConstantDefinition, compiler: &Compiler) -> HtmlElement<Div> {
    view! {
        <div class="panel feature constant">
            <h3 class="mono">
                {parent_module.clone().map(module_qualifier)} <span class="binding" inner_html=&item.name></span>
                " " <span class="badge">"constant"</span>
            </h3>
            {constant
                .value
                .as_ref()
                .map(|value| {
                    view! {
                        <details>
                            <summary>"Literal value"</summary>
                            <code class="literal-value">{value}</code>
                        </details>
                    }
                })}
            {documentation(item, &compiler)}
        </div>
    }
}

fn generate_named_signature_item(signature: Option<SignatureInfo>, named_signature: Option<NamedSignature>) -> HtmlElement<Div> {
    let hidden = if signature.is_none() && named_signature.is_none() {
        "hidden"
    } else {
        ""
    };

    view! {
        <div class=format!(
            "function-summary {}",
            hidden,
        )>
            {signature
                .map(|signature| {
                    view! { <span class="summary-badge signature">{format!("{signature}")}</span> }
                })}
            {named_signature
                .map(|signature| {
                    view! {
                        {signature
                            .outputs
                            .iter()
                            .map(|output| {
                                view! { <span class="summary-badge output">{output}</span> }
                            })
                            .collect_view()}
                        "?"
                        {signature
                            .inputs
                            .iter()
                            .map(|input| view! { <span class="summary-badge input">{input}</span> })
                            .collect_view()}
                    }
                })}
        </div>
    }
}

fn generate_function_signature_item(signature: SignatureInfo, inputs: Vec<FunctionArgument>, outputs: Vec<FunctionOutput>) -> HtmlElement<Div> {
    view! {
        <div class="function-summary">
            <span class="summary-badge signature">{format!("{signature}")}</span>
            {outputs
                .iter()
                .map(|output| generate_function_output_item(
                    output.name.clone(),
                    output.inferred,
                ))
                .collect_view()}
            {Some("?").take_if(|_| signature.inputs > 0 || signature.outputs > 0)}
            {inputs
                .iter()
                .map(|input| generate_function_input_item(
                    input.name.clone(),
                    input.inferred,
                    input.optional,
                    input.comment_name.clone(),
                ))
                .collect_view()}
        </div>
    }
}

fn generate_function_output_item(name: String, inferred: bool) -> HtmlElement<Span> {
    let span_class = generate_class(vec![("summary-badge output", true), ("inferred", inferred)]);

    view! {
        <span class=span_class>
            {name}
        </span>
    }
}

fn generate_function_input_item(name: String, inferred: bool, optional: bool, comment_name: Option<String>) -> HtmlElement<Span> {
    let span_class = generate_class(vec![("summary-badge input", true), ("inferred", inferred), ("optional", optional)]);

    let mut name = match optional || comment_name.is_some() {
        true => format!("{}:", name),
        false => name,
    };

    if let Some(comment_name) = comment_name {
        name.push_str(&format!("{}", comment_name));
    }

    view! {
        <span class=span_class>
            {name}
        </span>
    }
}

fn generate_function_item(
    parent_module: Option<String>,
    item: &BindingDefinition,
    function: &FunctionDefinition,
    compiler: &Compiler,
) -> HtmlElement<Div> {
    let source_code = format_source_code(&item.code, &compiler);

    view! {
        <div class=format!("panel feature {}", function.signature().color_class())>
            <h3 class="mono">
                {parent_module.map(module_qualifier)}
                <span class="binding">{&item.name}</span> " "
                <span class="badge">"function"</span>
                {Some(view! { " " <span class="badge">"has optional arguments"</span> }).take_if(|_| function.optional_inputs.len() > 0)}
            </h3>

            {generate_function_signature_item(
                function.signature().clone(),
                function.inputs().clone(),
                function.outputs.clone(),
            )}
            {documentation(item, &compiler)}

            <details>
                <summary>"Source code"</summary>
                <code class="source-code" inner_html=source_code></code>
            </details>
        </div>
    }
}

fn generate_index_macro_item(
    parent_module: Option<String>,
    item: &BindingDefinition,
    index_macro: &IndexMacroDefinition,
    compiler: &Compiler,
) -> HtmlElement<Div> {
    let source_code = format_source_code(&item.code, &compiler);

    view! {
        <div class=format!("panel feature {}", index_macro.color_class())>
            <h3 class="mono">
                {parent_module.map(module_qualifier)}
                <span class="binding">{&item.name}</span> " "
                <span class="badge">"index macro"</span>
            </h3>

            {generate_named_signature_item(None, index_macro.named_signature.clone())}
            {documentation(item, &compiler)}

            <details>
                <summary>"Source code"</summary>
                <code class="source-code" inner_html=source_code></code>
            </details>
        </div>
    }
}

fn generate_code_macro_item(
    parent_module: Option<String>,
    item: &BindingDefinition,
    index_macro: &CodeMacroDefinition,
    compiler: &Compiler,
) -> HtmlElement<Div> {
    let source_code = format_source_code(&item.code, &compiler);

    view! {
        <div class="panel feature monadic-modifier">
            <h3 class="mono">
                {parent_module.map(module_qualifier)}
                <span class="binding">{&item.name}</span> " "
                <span class="badge">"code macro"</span>
            </h3>

            {generate_named_signature_item(None, index_macro.named_signature.clone())}
            {documentation(item, &compiler)}

            <details>
                <summary>"Source code"</summary>
                <code class="source-code" inner_html=source_code></code>
            </details>
        </div>
    }
}

fn generate_module_item(parent_module: Option<String>, module: &ModuleDefinition, compiler: &Compiler) -> HtmlElement<Div> {
    view! {
        <div class="panel feature module">
            <h3 class="mono">
                {parent_module.map(module_qualifier)} <span class="binding">{&module.name}</span> " "
                <span class="badge">"module"</span>
            </h3>
            {documentation(module, &compiler)}
            <br />
            {module
                .items
                .iter()
                .map(|item| generate_content_item(Some(module.name.clone()), item, &compiler))
                .collect_view()}
        </div>
    }
}

pub fn box_description(definition: Option<&Definition>) -> &'static str {
    if let Some(def) = definition {
        if def.boxed {
            "boxed"
        } else {
            "unboxed"
        }
    } else {
        "no values"
    }
}

fn generate_class(values: Vec<(&str, bool)>) -> String {
    values
        .into_iter()
        .filter_map(|(class, condition)| if condition { Some(class.to_string()) } else { None })
        .collect::<Vec<_>>()
        .join(" ")
}

fn generate_data_item(parent_module: Option<String>, data: &DataDefinition, compiler: &Compiler) -> HtmlElement<Div> {
    fn badge_row(field: &Field) -> View {
        view! {
            <div class="badge-row">
                <span class="data-badge input">{&field.clone().name}</span>
                {&field
                    .validator
                    .clone()
                    .map(|validator| {
                        let (name, italics) = match validator.as_str() {
                            "째0type" => ("number array".into(), true),
                            "째1type" => ("complex array".into(), true),
                            "째2type" => ("box array".into(), true),
                            "째3type" => ("complex array".into(), true),
                            _ => (None, false),
                        };
                        let italics = if italics { "italics" } else { "" };
                        let name = if let Some(name) = name { name.to_string() } else { validator };

                        view! { <span class=format!("data-badge type {}", italics)>{name}</span> }
                    })
                    .collect_view()}
            </div>
        }
        .into_view()
    }

    view! {
        <div class="panel feature module">
            <h3 class="mono">
                {parent_module.map(module_qualifier)}
                <span class="binding">{data.name.clone().unwrap_or_default()}</span> " "
                <span class="badge">"data"</span> " "
                <span class="badge">{box_description(data.definition.as_ref())}</span>
            </h3>
            {documentation(data, &compiler)}
            {data
                .definition
                .as_ref()
                .map(|definition| {
                    view! {
                        <div class="data-summary">
                            {definition.fields.iter().map(badge_row).collect_view()}
                        </div>
                    }
                })}
        </div>
    }
}

fn generate_variant_item(parent_module: Option<String>, data: &VariantDefinition, compiler: &Compiler) -> HtmlElement<Div> {
    view! {
        <div class="panel feature module">
            <h3 class="mono">
                {parent_module.map(module_qualifier)} <span class="binding">{&data.name}</span> " "
                <span class="badge">"variant"</span> " "
                <span class="badge">{box_description(data.definition.as_ref())}</span>
            </h3>
            {documentation(data, &compiler)}
            {data
                .definition
                .as_ref()
                .map(|definition| {
                    view! {
                        <div class="data-summary variant">
                            {definition
                                .fields
                                .iter()
                                .map(|field| {
                                    view! {
                                        <div class="badge-row">
                                            <span class="data-badge input">{&field.name}</span>
                                        </div>
                                    }
                                })
                                .collect_view()}
                        </div>
                    }
                })}
        </div>
    }
}
